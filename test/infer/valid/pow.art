trait Mul {
    fn mul(a: Self, b: Self) -> Self;
}

trait Mod {
    fn mod(a: Self, b: Self) -> Self;
}

trait Div {
    fn div(a: Self, b: Self) -> Self;
}

trait Sub {
    fn sub(a: Self, b: Self) -> Self;
}

trait AssignMul {
    fn assign_mul(ptr: &mut Self, val: Self) -> ();
}

trait AssignDiv {
    fn assign_div(ptr: &mut Self, val: Self) -> ();
}

trait PostDec {
    fn dec(ptr: &mut Self) -> ();
}

trait CmpEq {
    fn cmp_eq(a: Self, b: Self) -> bool;
}

trait CmpGE {
    fn cmp_ge(a: Self, b: Self) -> bool;
}

trait Num : Sub + Mul + Div + Mod + AssignMul + AssignDiv + PostDec + CmpGE + CmpEq {}

impl Sub for i32;
impl Mul for i32;
impl Div for i32;
impl Mod for i32;
impl AssignMul for i32;
impl AssignDiv for i32;
impl PostDec for i32;
impl CmpEq for i32;
impl CmpGE for i32;
impl Num for i32;

fn pow_rec(x: i32, n: i32) -> i32 {
    if n == 0 {
        1
    } else if n % 2 == 0 {
        let y = pow_rec(x, n / 2);
        y * y
    } else {
        x * pow_rec(x, n - 1)
    }
}

fn pow_imp(x: i32, mut n: i32) -> i32 {
    let mut y = 1;
    while n >= 0 {
        if n % 2 == 0 {
            y *= y;
            n /= 2;
        } else {
            y *= x;
            n--;
        }
    }
    y
}
