fn @range(body: fn (i32) -> ()) {
    fn loop(beg: i32, end: i32) -> () {
        if beg < end {
            @body(beg);
            loop(beg + 1, end)
        }
    }
    loop
}

struct BBox {
    min: Vec3,
    max: Vec3
}

struct Sphere {
    center: Vec3,
    radius: f32
}

struct Triangle {
    verts: [Vec3 * 3]
}


trait Shape[T] {
    fn bbox(T) -> BBox;
}

impl Shape[Sphere] {
    fn bbox(s: Sphere) = BBox {
        min = s.center - vec_const[Vec3](s.radius),
        max = s.center + vec_const[Vec3](s.radius)
    };
}

impl Shape[Triangle] {
    fn bbox(t: Triangle) = BBox {
        min = min(min(t.verts(0), t.verts(1)), t.verts(2)),
        max = max(max(t.verts(0), t.verts(1)), t.verts(2))
    };
}

fn empty_bbox() = BBox {
    min = vec_const[Vec3]((+1:f32) / 0),
    max = vec_const[Vec3]((-1:f32) / 0)
};

fn extend(bbox: BBox, other: BBox) = BBox {
    min = min(bbox.min, other.min),
    max = max(bbox.max, other.max)
};

fn overall_bbox[T](shapes: &[T], length: i32) where Shape[T] {
    let mut bbox = empty_bbox();
    for i in range(0, length) {
        bbox = extend(bbox, Shape[T]::bbox(shapes(i)));
    }
    bbox
}

#[export]
fn main() {
    let s1 = Sphere { center = vec_const[Vec3](0), radius = 1 };
    let s2 = Sphere { center = vec_const[Vec3](1), radius = 1 };
    let t1 = Triangle {
        verts = [
            Vec3 { x = 0, y = 1, z = 0 },
            Vec3 { x = 1, y = 0, z = 0 },
            Vec3 { x = 1, y = 1, z = 0 },
        ]
    };
    let t2 = Triangle {
        verts = [
            Vec3 { x = 0, y = 1, z = 1 },
            Vec3 { x = 1, y = 0, z = 1 },
            Vec3 { x = 1, y = 1, z = 1 },
        ]
    };
    let b1 = overall_bbox[Sphere]([s1, s2], 2);
    let b2 = overall_bbox[Triangle]([t1, t2], 2);
    let ok =
        b1.min.x == -1 && b1.min.y == -1 && b1.min.z == -1 &&
        b1.max.x ==  2 && b1.max.y ==  2 && b1.max.z ==  2 &&
        b2.min.x ==  0 && b2.min.y ==  0 && b2.min.z ==  0 &&
        b2.max.x ==  1 && b2.max.y ==  1 && b2.max.z ==  1;
    if ok { 0 } else { 1 }
}
