struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

fn vec3_apply_unary(v: Vec3, f: fn(f32) -> f32) = Vec3 {
    x = f(v.x),
    y = f(v.y),
    z = f(v.z)
};

fn vec3_apply_binary(a: Vec3, b: Vec3, f: fn(f32, f32) -> f32) = Vec3 {
    x = f(a.x, b.x),
    y = f(a.y, b.y),
    z = f(a.z, b.z)
};

fn vec3_add(a: Vec3, b: Vec3) = vec3_apply_binary(a, b, |a, b| a + b);
fn vec3_sub(a: Vec3, b: Vec3) = vec3_apply_binary(a, b, |a, b| a - b);
fn vec3_min(a: Vec3, b: Vec3) = vec3_apply_binary(a, b, |a, b| cpu_intrinsics.fminf(a,b));
fn vec3_max(a: Vec3, b: Vec3) = vec3_apply_binary(a, b, |a, b| cpu_intrinsics.fmaxf(a,b));

struct BBox {
    min: Vec3,
    max: Vec3
}

struct Sphere {
    center: Vec3,
    radius: f32
}

struct Triangle {
    vertices: [Vec3 * 3],
    normal: Vec3
}

fn bbox_from_sphere(s: Sphere) = BBox {
    min = vec3_sub(s.center, Vec3 { x = s.radius, y = s.radius, z = s.radius }),
    max = vec3_add(s.center, Vec3 { x = s.radius, y = s.radius, z = s.radius })
};

fn bbox_from_triangle(t: Triangle) = BBox {
    min = vec3_min(vec3_min(t.vertices(0), t.vertices(1)), t.vertices(2)),
    max = vec3_min(vec3_min(t.vertices(0), t.vertices(1)), t.vertices(2)),
};


trait Shape[T] {
    fn get_bbox(t: T) -> BBox;
}

impl Shape[Sphere] {
    fn get_bbox(s: Sphere) = bbox_from_sphere(s);
}

impl Shape[Triangle] {
    fn get_bbox(s: Triangle) = bbox_from_triangle(s);
}

// length >= 1
fn overall_bbox[T](list: &[T], length: i32) -> BBox where Shape[T] {
    let mut acc = Shape[T]::get_bbox(list(0));
    for i in range(1, length) {
        let bbox = Shape[T]::get_bbox(list(i));
        acc.min = vec3_min(acc.min, bbox.min);
        acc.max = vec3_max(acc.max, bbox.max);
    }
    return (acc)
}
